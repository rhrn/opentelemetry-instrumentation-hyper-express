{"version":3,"file":"instrumentation.js","sourceRoot":"","sources":["../../src/instrumentation.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type * as types from './internal-types';\nimport type { Response, MiddlewareNext, MiddlewareHandler } from 'hyper-express';\n\nimport * as api from '@opentelemetry/api';\nimport type { Server } from 'hyper-express';\nimport { LayerType } from './types';\nimport { AttributeNames, LIBRARY_NAME, SpanName, SpanTags, SpanKind as SpanKindAttr } from './enums/AttributeNames';\n// import { VERSION } from './version';\nimport * as constants from './constants';\nimport {\n  InstrumentationBase,\n  InstrumentationNodeModuleDefinition,\n  InstrumentationNodeModuleFile,\n  isWrapped,\n  safeExecuteInTheMiddle,\n} from '@opentelemetry/instrumentation';\nimport { SEMATTRS_HTTP_CLIENT_IP, SEMATTRS_HTTP_HOST, SEMATTRS_HTTP_METHOD, SEMATTRS_HTTP_ROUTE, SEMATTRS_HTTP_STATUS_CODE, SEMATTRS_HTTP_TARGET, SEMATTRS_HTTP_URL, SEMATTRS_HTTP_USER_AGENT } from '@opentelemetry/semantic-conventions';\nimport { isPromise, isAsyncFunction, parseResponseStatus, getScheme } from './utils';\nimport { getRPCMetadata, RPCType } from '@opentelemetry/core';\nimport type { HyperExpressInstrumentationConfig } from './types';\nimport { SpanKind } from '@opentelemetry/api';\n\nconst APM_TYPE = process.env.APM_TYPE;\nconst SEMATTRS_HTTP_REQUEST_ID = 'http.x_request_id';\n\nexport class HyperExpressInstrumentation extends InstrumentationBase {\n  constructor(config: HyperExpressInstrumentationConfig = {}) {\n    super(\n      `@opentelemetry/instrumentation-${constants.MODULE_NAME}`,\n      \"0.38.0\",\n      config\n    );\n  }\n\n  private _moduleVersion?: string;\n  private _isDisabled = false;\n\n  override setConfig(config: HyperExpressInstrumentationConfig = {}) {\n    this._config = Object.assign({}, config);\n  }\n\n  override getConfig(): HyperExpressInstrumentationConfig {\n    return this._config as HyperExpressInstrumentationConfig;\n  }\n\n  init() {\n    const module = new InstrumentationNodeModuleDefinition(\n      constants.MODULE_NAME,\n      constants.SUPPORTED_VERSIONS,\n      (moduleExports, moduleVersion) => {\n        this._moduleVersion = moduleVersion;\n        return moduleExports;\n      }\n    );\n\n    module.files.push(\n      new InstrumentationNodeModuleFile(\n        'hyper-express/src/components/Server.js',\n        constants.SUPPORTED_VERSIONS,\n        moduleExports => {\n          this._isDisabled = false;\n          const Server: any = moduleExports;\n          for (const name of constants.HYPER_EXPRESS_METHODS) {\n            // console.log(\"name\", name);\n            if (isWrapped(Server.prototype[name])) {\n              this._unwrap(Server.prototype, name);\n            }\n            this._wrap(\n              Server.prototype,\n              name as keyof Server,\n              this._methodPatcher.bind(this)\n            );\n          }\n          for (const name of constants.HYPER_EXPRESS_MW_METHODS) {\n            if (isWrapped(Server.prototype[name])) {\n              this._unwrap(Server.prototype, name);\n            }\n            this._wrap(\n              Server.prototype,\n              name as keyof Server,\n              this._middlewarePatcher.bind(this)\n            );\n          }\n          return moduleExports;\n        },\n        moduleExports => {\n          this._isDisabled = true;\n          if (moduleExports) {\n            const Server: any = moduleExports;\n            for (const name of constants.HYPER_EXPRESS_METHODS) {\n              this._unwrap(Server.prototype, name as keyof Server);\n            }\n            for (const name of constants.HYPER_EXPRESS_MW_METHODS) {\n              this._unwrap(Server.prototype, name as keyof Server);\n            }\n          }\n        }\n      )\n    );\n\n    return module;\n  }\n\n  private _middlewarePatcher(original: Function, methodName?: string) {\n    const instrumentation = this;\n    return function (this: Server, ...handler: types.NestedRequestHandlers) {\n      return original.call(\n        this,\n        instrumentation._handlerPatcher(\n          { type: LayerType.MIDDLEWARE, methodName },\n          handler\n        )\n      );\n    };\n  }\n\n  private _methodPatcher(original: Function, methodName?: string) {\n    const instrumentation = this;\n    return function (\n      this: Server,\n      path: any,\n      ...handler: types.NestedRequestHandlers\n    ) {\n      return original.call(\n        this,\n        path,\n        ...instrumentation._handlerPatcher(\n          { type: LayerType.REQUEST, path, methodName },\n          handler\n        )\n      );\n    };\n  }\n\n  // will return the same type as `handler`, but all functions recursively patched\n  private _handlerPatcher(\n    metadata: types.Metadata,\n    handler: MiddlewareHandler | types.NestedRequestHandlers\n  ): any {\n    if (Array.isArray(handler)) {\n      return handler.map(handler => this._handlerPatcher(metadata, handler));\n    }\n    if (typeof handler === 'function') {\n      return (\n        req: types.Request,\n        res: Response,\n        next: MiddlewareNext\n      ) => {\n        if (this._isDisabled) {\n          return handler(req, res, next);\n        }\n        // const route =\n        //   typeof req.getRoute === 'function'\n        //     ? req.getRoute()?.path\n        //     : req.route?.path;\n        //@ts-ignore\n        const reqRoute = req.route;\n        // console.log(\"req.route\", reqRoute);\n        const route = reqRoute.pattern;\n        // console.log(\"yello\", req, req.app);\n        // replace HTTP instrumentations name with one that contains a route\n        const httpMetadata = getRPCMetadata(api.context.active());\n        if (httpMetadata?.type === RPCType.HTTP) {\n          httpMetadata.route = route;\n        }\n\n        const fnName = handler.name || undefined;\n        const resource =\n          metadata.type === LayerType.REQUEST\n            ? `${reqRoute.method} ${route}`\n            : `middleware - ${fnName || 'anonymous'}`;\n        let spanName = '';\n        switch (APM_TYPE) {\n          case 'DD':\n            spanName = metadata.type === LayerType.REQUEST ? SpanName.REQUEST : SpanName.MIDDLEWARE;\n            break;\n          case 'ELASTIC':\n            spanName = resource;\n            break;\n        }\n        let attributes: any = {\n          [AttributeNames.NAME]: fnName,\n          [AttributeNames.VERSION]: this._moduleVersion || 'n/a',\n          [AttributeNames.TYPE]: metadata.type,\n          [AttributeNames.METHOD]: reqRoute.method,\n          [SpanTags.COMPONENT]: LIBRARY_NAME,\n          [SpanTags.KIND]: SpanKindAttr.SERVER,\n          [SpanTags.RESOURCE]: resource,\n        };\n\n        if (metadata.type === LayerType.REQUEST) {\n          //@ts-ignore\n          attributes[SEMATTRS_HTTP_ROUTE] =  route,\n          attributes[SEMATTRS_HTTP_HOST] = req.headers.host; \n          attributes[SEMATTRS_HTTP_METHOD] = reqRoute.method;\n          attributes[SEMATTRS_HTTP_USER_AGENT] = req.headers['user-agent'];\n          attributes[SEMATTRS_HTTP_TARGET] = route;\n          attributes[SEMATTRS_HTTP_URL] = getScheme(req.app) + req.headers.host + req.url; \n          attributes[SEMATTRS_HTTP_CLIENT_IP] = req.ip;\n          attributes[SEMATTRS_HTTP_REQUEST_ID] = req.headers['x-request-id'];\n        }\n        const span = this.tracer.startSpan(\n          spanName,\n          {\n            attributes,\n            kind: metadata.type === LayerType.REQUEST ? 1 : 0,\n          },\n          api.context.active()\n        );\n\n        const instrumentation = this;\n        const requestHook = instrumentation.getConfig().requestHook;\n        if (requestHook) {\n          safeExecuteInTheMiddle(\n            () => {\n              return requestHook!(span, {\n                request: req,\n                layerType: metadata.type,\n              });\n            },\n            e => {\n              if (e) {\n                instrumentation._diag.error('request hook failed', e);\n              }\n            },\n            true\n          );\n        }\n\n        const patchedNext = (err?: any) => {\n          if (err) {\n            span.end();\n          }\n          next(err);\n        };\n        // patchedNext.ifError = next.ifError; // todo: fix me\n\n        const wrapPromise = (promise: Promise<unknown>) => {\n          return promise\n            .then(value => {\n              // console.log(\"wrapPromise\", res.statusCode, metadata.type);\n              if (metadata.type === LayerType.REQUEST) {\n                // console.log(\"wrapPromise\", res.statusCode, metadata.type);\n                // span.setAttribute(SEMATTRS_HTTP_STATUS_CODE, res.statusCode);\n                span.setAttributes({\n                  [SEMATTRS_HTTP_STATUS_CODE]: res.statusCode,\n                });\n                span.setStatus({\n                  code: parseResponseStatus(SpanKind.SERVER, res.statusCode),\n                });\n              }\n              // span.setAttribute(AttributeNames.STATUS_CODE, res.statusCode);\n              \n              span.end();\n              return value;\n            })\n            .catch(err => {\n              span.recordException(err);\n              span.end();\n              throw err;\n            });\n        };\n\n        // console.log(\"lol\", api.context.active(), span);\n        const newContext = api.trace.setSpan(api.context.active(), span);\n        return api.context.with(\n          newContext,\n          (req: types.Request, res: Response, next: MiddlewareNext) => {\n            if (isAsyncFunction(handler)) {\n              return wrapPromise(handler(req, res, next));\n            }\n            try {\n              const result = handler(req, res, next);\n              if (isPromise(result)) {\n                return wrapPromise(result);\n              }\n              span.end();\n              return result;\n            } catch (err: any) {\n              span.recordException(err);\n              span.end();\n              throw err;\n            }\n          },\n          this,\n          req,\n          res,\n          patchedNext\n        );\n      };\n    }\n\n    return handler;\n  }\n}\n"]}